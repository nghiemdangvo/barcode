# -*- coding: utf-8 -*-
"""
Created on Sun Apr 14 14:28:46 2019

@author: Du Jiang

tesed operating system: Windows 7, Windows 10

task:
    combine barcodes that are ligetimately the same

input:
    step 2 results, i.e. bin files named as '{cell_sample}.bin'

variables subject to change:
    1. step2_location: directory where the step1 results are stored. default 'step-2'
    2. distance_allowed: edit distance allowed when determining whether two sequences are legitimately the same
    3. step3_output: folder to save output files. default 'step-2'

output:
    1. bin and txt files storing copy number of each barcode
        -- the bin file stores a dictionary with 'master barcodes' as keys, and dictionary(ies) as items;
           the lower level dictionary stores barcodes as keys, and their copy numbers as items.
        -- the txt file is a two column tab-delimited file:
           first column is 'master barcodes', second column is total copy number of the master barcode.
    2. excel files storing Levenshtein distances
    3. stat.txt files storing quality report for each cell sample

"""

#subject to change
step2_location = r'step-2'
distance_allowed = 4
step3_output = r'step-3'

#packages
import os
import time
import pickle
import numpy as np
import pandas as pd
from Levenshtein import distance
from itertools import combinations

#main
def main():
    starttime = time.time()
    #check if the output folder exists. If not, will create one
    if not os.path.exists(step3_output):
        os.makedirs(step3_output)
    
    #process each bin files generated in step-2
    results = []
    for fd in openFiles(step2_location, encoding="utf-8", errors='ignore'):
        results.append(combineMisreads(fd))
    
    #summarize the results in one stats.txt file
    with open(os.path.join(step3_output, 'step3_stats.txt'), 'w') as wf:
        wf.writelines('sample\ttotal reads of codes with 2 reads or more\ttotal codes\tcodes with 2 reads or more\tcombined codes\n')
        writeStatFile(wf, results)
    
    #final
    elapsed = time.time() - starttime
    hrs, rem = divmod(elapsed, 3600)
    mins, secs = divmod(rem, 60)
    print ("Total execution time: %d hours, %02d mins, %02d secs." %(int(hrs), int(mins), int(secs)))

def openFiles(location):
    """
    read individual bin files generated in step-2
    the data store in each bin file is a dictionary, with sequence as keys and its copy number as items
    """
    for fil in os.listdir(location):
        if not fil.endswith('.bin'):
            continue
        fname = fil.split('.')[0]
        
        #load data from bin file
        f = open(os.path.join(location, fil))
        dic = pickle.load(f) #key:sequence; item: copy number
        f.close()
        
        yield (fname, dic)

def combineMisreads(fd):
    fname,dic = fd
    print ('Processing', fname, '...')
    
    #put together all barcodes
    barcodes = [] #list storing all the barcodes
    total = 0
    for seq in dic.keys():
        #exclude the barcodes with a copy number of 1
        if dic[seq] > 1:
            barcodes.append(seq)
            total += dic[seq]
    print (fname, ": There are", len(barcodes), "sequences with more than one read.")
    
    #pairwise comparison of remaining barcodes
    similar = []
    count = 0
    for s1,s2 in combinations(range(len(barcodes)), 2):
        #if Levenshtein distance between two barcodes are below the variable "distance_allowed",
        #this pair will be recorded in the list "similar"
        if distance(barcodes[s1], barcodes[s2]) <= distance_allowed:
            similar.append([s1, s2])
        count += 1
        if count % 1000000 == 0:
            print (fname, ':', count, 'out of', len(barcodes)*(len(barcodes)-1)*.5, 'is done.')
    print (fname, " finished pairwise comparing sequences.")
    print (fname, " start generating a unique sequence list...")
    
    #classify barcodes into groups if they are similar enough as determined above
    indices = zunq(similar, len(barcodes))
    print (fname, " finished combining unique sequence.")
    
    #for each barcode group, determine master barcode by copy number
    master_barcodes = []
    #go through individual barcode groups, find the barcode with the highest copy number and set it as master barcode
    for i in range(len(indices)):
        largest = 0
        master = ''
        for j in indices[i]:
            if dic[barcodes[j]] > largest:
                master = barcodes[j]
                largest = dic[barcodes[j]]
        master_barcodes.append(master)
    
    #because the initial barcode groups were generated by pairwise comparison, it is possible that within each group,
    #there are some barcodes whose distance with the master barcode of the group is larger than expected; therefore, we
    #re-classify barcodes by going through each master barcode and retaining the barcodes that are similar enough to it
    final_dic = {}
    for master in master_barcodes:
        sub_dic = {}
        ind = barcodes.index(master)
        sub_dic[master] = dic[master]
        for i1,i2 in similar:
            if i1 == ind:
                sub_dic[barcodes[i2]] = dic[barcodes[i2]]
            elif i2 == ind:
                sub_dic[barcodes[i1]] = dic[barcodes[i1]]
        final_dic[master] = sub_dic
    #final_dic = {'master barcode1':{'barcode11':n11, 'barcode12':n12, ...},
    #             'master barcode2':{'barcode21':n21, 'barcode22':n22, ...},
    #             ...}
    
    #generate a tab-delimited text file
    #each row represents data from one group (clone)
    #first column is the master barcode of this group
    #second column is the total copy number of all the barcodes in this group
    totalcount = {}
    with open(os.path.join(step3_output, fname + '_' + str(total) + '.txt'), 'w') as wf:
        wf.writelines('barcode\tcount\n')
        for master in final_dic:
            number = 0
            for k in final_dic[master]:
                number += final_dic[master][k]
            wf.writelines(master + '\t' + str(number) + '\n')
            totalcount[master] = number
    
    #generate bin files storing the 'final_dic'
    fp = open(os.path.join(step3_output, fname +'_'+ str(total) +'.bin'), 'w')
    pickle.dump(final_dic, fp)
    fp.close()
    
    #generate excel files storing the Levenshtein distances information of the sample:
    #   sheet 'intraclonal': shows the copy number of each barcode and its distance with the master barcode
    #   sheet 'interclonal': shows the distance between master barcodes
    frame1 = pd.DataFrame()
    frow1 = 0
    for master in sorted(totalcount, key=lambda m:totalcount[m], reverse=True):
        for code in sorted(final_dic[master].keys(), key=lambda c:int(final_dic[master][c]), reverse=True):
            frame1.loc[frow1, 'master'] = master
            frame1.loc[frow1, 'barcode'] = code
            frame1.loc[frow1, 'count'] = final_dic[master][code]
            frame1.loc[frow1, 'distance'] = distance(master, code)
            frow1 += 1
    frame2 = pd.DataFrame()
    frow2 = 0
    for master1,master2 in combinations(totalcount, 2):
        frame2.loc[frow2, 'master1'] = master1
        frame2.loc[frow2, 'master2'] = master2
        frame2.loc[frow2, 'distance'] = distance(master1, master2)
        frow2 += 1
    frame2.sort_values(by='distance', inplace=True, ascending=True)
    with pd.ExcelWriter(os.path.join(step3_output, fname+'.xlsx')) as xlsx:
        frame1.to_excel(xlsx, sheet_name='intraclonal', index=False, header=True)
        frame2.to_excel(xlsx, sheet_name='interclonal', index=False, header=True)
    
    #return results
    print (fname, total, len(dic), len(barcodes), len(final_dic), '\n')
    return (fname, str(total), str(len(dic)), str(len(barcodes)), str(len(final_dic)))

def zunq(listPairs, intNIndivElements):
    """
    input:
        listPairs: list of barcode pairs that are similar (distance below the variable "distance_allowed")
        intNIndivElements: number of barcodes
    task:
        classify similar barcodes into the same group
    return:
        groups of barcodes
    """
    #initiate an array to store group information for all barcodes
    arrElementGroup = -1*np.ones(intNIndivElements, 'int32')
    
    listGroups = []
    count = 0
    #go through the barcode pairs that are to be grouped together
    for i in listPairs:
        #if the first barcode in this pair does not have group information yet
        if arrElementGroup[i[0]] == -1:
            #if the second barcode in this pair also does not have group information yet
            if arrElementGroup[i[1]] == -1:
                #create a new group and put these two barcodes in
                listGroups.append([])
                arrElementGroup[i[0]] = len(listGroups) - 1 #change the group information of first barcode in the array
                arrElementGroup[i[1]] = len(listGroups) - 1 #change the group information of second barcode in the array
                listGroups[-1].append(i[0])
                listGroups[-1].append(i[1])
            #if the second barcode already have group information
            else:
                #put the first barcode in the same group with the second barcode
                listGroups[arrElementGroup[i[1]]].append(i[0])
                arrElementGroup[i[0]] = arrElementGroup[i[1]]
        #if the first barcode in this pair already have group information
        else:
            #if the second barcode in this pair does not have group information yet
            if arrElementGroup[i[1]] == -1:
                #put the second barcode in the same group with the first barcode
                listGroups[arrElementGroup[i[0]]].append(i[1])
                arrElementGroup[i[1]] = arrElementGroup[i[0]]
            #if the second barcode also already have group information
            else:
                #if these two barcodes were previously assigned with different group information
                if arrElementGroup[i[0]] != arrElementGroup[i[1]]:
                    #combine these two groups into one
                    intTemp = arrElementGroup[i[1]]
                    for q in listGroups[arrElementGroup[i[1]]]:
                        arrElementGroup[q] = arrElementGroup[i[0]]
                    temp = listGroups[arrElementGroup[i[0]]] + listGroups[intTemp]
                    listGroups[arrElementGroup[i[0]]] = temp
                    listGroups[intTemp] = []
        count += 1
    
    #elements in the returning list are lists of barcodes indices; these lists can have one or more items in it
    ret = []
    #first, if a barcode is not similar enough with any other barcodes, it will form a group itself
    for i in range(0, intNIndivElements):
        if arrElementGroup[i] == -1:
            ret.append([i])
    #second, the groups we created above will be appended to the returning list
    for i in listGroups:
        if i != []:
            ret.append(i)
    print ("There are ", len(ret), " groups")
    return ret

def writeStatFile(wf, results):
    for result in results:
        a,b,c,d,e = result
        wf.writelines(a +'\t'+ b +'\t'+ c +'\t'+ d +'\t'+ e +'\n')

if __name__ == '__main__':
    main()